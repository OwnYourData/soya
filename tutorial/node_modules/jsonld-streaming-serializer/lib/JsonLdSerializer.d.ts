/// <reference types="node" />
import EventEmitter = NodeJS.EventEmitter;
import { JsonLdContextNormalized, JsonLdContext } from "jsonld-context-parser";
import * as RDF from "@rdfjs/types";
import { Transform, TransformCallback } from "stream";
import { SeparatorType } from "./SeparatorType";
/**
 * A stream transformer that transforms an {@link RDF.Stream} into a JSON-LD (text) stream.
 */
export declare class JsonLdSerializer extends Transform {
    private readonly options;
    private readonly originalContext;
    private readonly context;
    private indentation;
    private opened;
    private lastSubject;
    private lastPredicate;
    private hadObjectForPredicate;
    private objectOptions;
    private lastGraph;
    constructor(options?: IJsonLdSerializerOptions);
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {NodeJS.EventEmitter} A quad stream.
     */
    import(stream: EventEmitter): EventEmitter;
    /**
     * Transforms a quad into the text stream.
     * @param {Quad} quad An RDF quad.
     * @param {string} encoding An (ignored) encoding.
     * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the transformation is done
     * @private
     */
    _transform(quad: RDF.Quad, encoding: string, callback: TransformCallback): void;
    /**
     * Construct a list in an RDF.Term object that can be used
     * inside a quad's object to write into the serializer
     * as a list using the @list keyword.
     * @param {RDF.Quad_Object[]} values A list of values, can be empty.
     * @return {RDF.Quad_Object} A term that should be used in the object position of the quad that is written to the serializer.
     */
    list(values: RDF.Term[]): Promise<RDF.Quad_Object>;
    /**
     * Claled when the incoming stream is closed.
     * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the flushing is done.
     * @private
     */
    _flush(callback: TransformCallback): void;
    /**
     * Transforms a quad into the text stream.
     * @param {Quad} quad An RDF quad.
     * @param {JsonLdContextNormalized} context A context for compacting.
     */
    protected transformQuad(quad: RDF.Quad, context: JsonLdContextNormalized): void;
    protected pushDocumentStart(): void;
    /**
     * Push the given term as an @id field.
     * @param {Term} term An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     */
    protected pushId(term: RDF.Term, context: JsonLdContextNormalized): void;
    /**
     * Push the given predicate field.
     * @param {Term} predicate An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     */
    protected pushPredicate(predicate: RDF.Term, context: JsonLdContextNormalized): void;
    /**
     * Push the given object value.
     * @param {Term} object An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     */
    protected pushObject(object: RDF.Term, context: JsonLdContextNormalized): boolean;
    protected endDocument(): void;
    /**
     * Push the end of a predicate and reset the buffers.
     * @param {boolean} comma If a comma should be appended.
     */
    protected endPredicate(comma?: boolean): void;
    /**
     * Push the end of a subject and reset the buffers.
     * @param {boolean} comma If a comma should be appended.
     */
    protected endSubject(comma?: boolean): void;
    /**
     * Push the end of a graph and reset the buffers.
     * @param {boolean} comma If a comma should be appended.
     */
    protected endGraph(comma?: boolean): void;
    /**
     * Puh the given separator.
     * @param {SeparatorType} type A type of separator.
     */
    protected pushSeparator(type: SeparatorType): void;
    /**
     * An indentation-aware variant of {@link #push}.
     * All strings that are pushed here will be prefixed by {@link #indentation} amount of spaces.
     * @param {string} data A string.
     */
    protected pushIndented(data: string): void;
    /**
     * @return {string} Get the current indentation prefix based on {@link #indentation}.
     */
    protected getIndentPrefix(): string;
}
/**
 * Constructor arguments for {@link JsonLdSerializer}
 */
export interface IJsonLdSerializerOptions {
    /**
     * The indentation string that should be used when stringifying JSON.
     * Defaults to undefined.
     */
    space?: string;
    /**
     * If '@id' objects without other entries should be compacted.
     * Defaults to false.
     */
    compactIds?: boolean;
    /**
     * If rdf:type predicates should be emitted directly, instead of @type.
     * Defaults to false.
     */
    useRdfType?: boolean;
    /**
     * If literals should be converted to primitive types, such as booleans and integers.
     * Defaults to false.
     */
    useNativeTypes?: boolean;
    /**
     * An optional base IRI for compacting terms.
     * Defaults to null.
     */
    baseIRI?: string;
    /**
     * An optional JSON-LD context for compacting terms.
     * Defaults to null.
     */
    context?: JsonLdContext;
    /**
     * If the context should not be serialized, even if one was supplied.
     * This can be used if the context will be attached to the document through alternative means.
     * Defaults to false.
     */
    excludeContext?: boolean;
    /**
     * The mode by which the values with a certain base direction should be transformed from RDF.
     * * 'i18n-datatype': objects have a https://www.w3.org/ns/i18n# datatype.
     * * 'compound-literal': reified values using rdf:value, rdf:direction and rdf:language.
     */
    rdfDirection?: 'i18n-datatype' | 'compound-literal';
}
