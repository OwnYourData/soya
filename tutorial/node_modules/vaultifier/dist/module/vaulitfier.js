var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Communicator } from './communicator';
import { MimeType, StorageKey } from './constants';
import { decrypt, encrypt, generateHashlink } from './crypto';
import { UnauthorizedError } from './errors';
import { decryptOrNot, parseVaultItem, parseVaultItemMeta } from './helpers';
import { OAuthType, } from './interfaces';
import { Storage } from './storage';
import { VaultifierUrls } from './urls';
export class Vaultifier {
    /**
     *
     * @param baseUrl The base url of your data vault (e.g. https://data-vault.eu).
     * @param repo Repository, where to write to. This is defined in your plugin's manifest
     * @param credentials "Identifier" (appKey) that was generated after registering the plugin. "Secret" (appSecret) that was generated after registering the plugin.
     * @param privateKeyCredentials Credentials for decrypting E2E encrypted data
     * @param allowOnlyUniqueValues Specifies, if DRI should be calculated for every value. If `true`, the data store will only allow unique values.
     */
    constructor(baseUrl, repo, credentials, privateKeyCredentials, allowOnlyUniqueValues = false) {
        this.repo = repo;
        this.credentials = credentials;
        this.privateKeyCredentials = privateKeyCredentials;
        this.allowOnlyUniqueValues = allowOnlyUniqueValues;
        /**
         * This enables to intercept all network calls made by Vaultifier
         * This is helpful, if you are already using a library for all your network calls
         * If "setNetworkAdapter" is called without providing an adapter, Vaultifier's default adapter is used
         *
         * @param {NetworkAdapter} [adapter]
         *
         * @returns {NetworkAdapter} the network adapter that will be used by Vaultifier
         */
        this.setNetworkAdapter = (adapter) => this.communicator.setNetworkAdapter(adapter);
        /**
         * A generic method to post data to the Data Vault
         *
         * @param url Url where to send the request to. Has to start with a leading slash "/"
         * @param usesAuth Whether or not the call should be authorized or not
         * @param data Data to pass to the endpoint
         */
        this.post = (url, usesAuth, data) => __awaiter(this, void 0, void 0, function* () { return this.communicator.post(this.urls.getGenericUrl(url), usesAuth, data); });
        /**
         * A generic method to put data to the Data Vault
         *
         * @param url Url where to send the request to. Has to start with a leading slash "/"
         * @param usesAuth Whether or not the call should be authorized or not
         * @param data Data to pass to the endpoint
         */
        this.put = (url, usesAuth, data) => __awaiter(this, void 0, void 0, function* () { return this.communicator.put(this.urls.getGenericUrl(url), usesAuth, data); });
        /**
         * A generic method to get data from the Data Vault
         *
         * @param url Url where to send the request to. Has to start with a leading slash "/"
         * @param usesAuth Whether or not the call should be authorized or not
         */
        this.get = (url, usesAuth) => __awaiter(this, void 0, void 0, function* () { return this.communicator.get(this.urls.getGenericUrl(url), usesAuth); });
        this.urls = new VaultifierUrls(baseUrl, repo);
        this.communicator = new Communicator();
    }
    getPaging(response) {
        const currentPage = response.headers['current-page'];
        const totalPages = response.headers['total-pages'];
        const totalItems = response.headers['total-count'];
        const pageItems = response.headers['page-items'];
        return {
            current: typeof currentPage === 'string' ? parseInt(currentPage) : currentPage,
            totalPages: typeof totalPages === 'string' ? parseInt(totalPages) : totalPages,
            totalItems: typeof totalItems === 'string' ? parseInt(totalItems) : totalItems,
            pageItems: typeof pageItems === 'string' ? parseInt(pageItems) : pageItems,
        };
    }
    parsePostResult(response) {
        const { data } = response;
        const { responses } = data;
        if (!Array.isArray(responses) || responses.length === 0)
            throw new Error('Could not parse post response.');
        return {
            id: data.responses[0].id,
            raw: data,
        };
    }
    /**
     * Returns an object that can be checked for supported features of the provided endpoint
     */
    getVaultSupport() {
        return __awaiter(this, void 0, void 0, function* () {
            // only fetch it once
            if (this.supports)
                return this.supports;
            const { data } = yield this.communicator.get(this.urls.active);
            const oAuth = [];
            if (Array.isArray(data.oauth)) {
                for (const provider of data.oauth) {
                    if (provider.type === OAuthType.CLIENT_CREDENTIALS ||
                        provider.type === OAuthType.AUTHORIZATION_CODE) {
                        oAuth.push(provider);
                    }
                    else {
                        oAuth.push({
                            authority: provider.authority,
                            clientId: provider.client_id,
                            scope: provider.scope,
                            responseType: provider.response_type,
                            redirectUrl: provider.redirect_url,
                            title: provider.title,
                            imageUrl: provider.title.pic,
                            applicationId: provider.application_id,
                        });
                    }
                }
                // if OAuth type is not specified by server, we assume the default, which is client_credentials
                // but only if auth is set to true
            }
            else if (data.auth) {
                oAuth.push({
                    type: OAuthType.CLIENT_CREDENTIALS,
                });
            }
            return this.supports = {
                repos: !!data.repos,
                authentication: !!data.auth,
                scopes: data.scopes,
                oAuth,
            };
        });
    }
    /**
     * Returns an object with data that describes the Vault
     */
    getVaultInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.info)
                return this.info;
            const { data } = yield this.communicator.get(this.urls.info, true);
            return this.info = data;
        });
    }
    /**
     * Retrieves the usage policy of the give data vault
     *
     * @returns the usage policy (which format is (Turtle)[https://www.w3.org/TR/turtle/]) as a string
     */
    getUsagePolicy() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.usagePolicy, true);
            return data;
        });
    }
    /**
     * Sets the vault's credentials
     *
     * @param credentials Object containing credentials
     */
    setCredentials(credentials) {
        this.credentials = credentials;
    }
    /**
     * Returns true, if vault has (probably) valid credentials
     * This does not indicate, whether the vault will accept the credentials or not!
     */
    hasCredentials() {
        return !!this.credentials && !!this.credentials.appKey && !!this.credentials.appSecret;
    }
    /**
     * Initializes Vaultifier (authorizes against data vault if necessary)
     *
     * @returns {Promise<void>}
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const supports = yield this.getVaultSupport();
            if (supports.authentication) {
                this.communicator.setTokenCallback(() => this._authorize());
                yield this.communicator.refreshToken();
            }
        });
    }
    /**
     * This switches to the given repository name
     * As the data vault also provides the functionality to have public keys per repo
     * this function could be used to create a new instance of Vaultifier
     * But as this functionality is not yet active, it just changes the repo without doing anything further
     *
     * @param repoId Repository that should be used in the returned instance of Vaultifier
     */
    fromRepo(repoId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.repo = repoId;
            this.urls.setRepo(repoId);
            return this;
        });
    }
    /**
     * Enables or disables end-to-end encryption
     * TODO: this should always be enabled by default
     *
     * @param isActive
     */
    setEnd2EndEncryption(isActive = true) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const e2eKeysKey = 'e2e-keys';
            // if endpoint does not support repos, there is no way to encrypt data, because of missing public key
            if (!isActive || !((_a = this.supports) === null || _a === void 0 ? void 0 : _a.repos)) {
                this.publicKey = undefined;
                this.privateKey = undefined;
            }
            else {
                try {
                    this.publicKey = (yield this.communicator.get(this.urls.publicKey(), true))
                        .data.public_key;
                    if (this.privateKeyCredentials) {
                        const { nonce, masterKey } = this.privateKeyCredentials;
                        const encryptedPassword = (yield this.communicator.get(this.urls.getEncryptedPassword(this.privateKeyCredentials.nonce)))
                            .data.cipher;
                        const password = yield decrypt({
                            value: encryptedPassword,
                            nonce,
                        }, {
                            cipher: masterKey,
                            isHashed: true,
                        });
                        const encryptedPrivateKey = JSON.parse((yield this.communicator.get(this.urls.privateKey, true))
                            .data.password_key);
                        this.privateKey = yield decrypt(encryptedPrivateKey, { cipher: password });
                    }
                    // basically, this "if" is not really necessary
                    // it just assures we do not read from the storage unnecessarily
                    // probably this does not make any difference in performance, but I consider it as good practice :-)
                    if (!this.publicKey || !this.privateKey) {
                        const storedKeys = Storage.getObject(e2eKeysKey);
                        if (storedKeys) {
                            if (!this.publicKey)
                                this.publicKey = storedKeys.publicKey;
                            if (!this.privateKey)
                                this.privateKey = storedKeys.privateKey;
                        }
                    }
                    Storage.set(e2eKeysKey, {
                        privateKey: this.privateKey,
                        publicKey: this.publicKey,
                    });
                }
                catch ( /* Yeah I know, error handling could be done better here... */_b) { /* Yeah I know, error handling could be done better here... */ }
            }
            return this.getEncryptionSupport();
        });
    }
    getEncryptionSupport() {
        return {
            supportsEncryption: !!this.publicKey,
            supportsDecryption: !!this.privateKey,
        };
    }
    get _usesEncryption() { return this.publicKey !== undefined && this.publicKey.length > 0; }
    encryptOrNot(value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._usesEncryption &&
                this.publicKey) {
                const dataString = JSON.stringify(value);
                return encrypt(dataString, this.publicKey);
            }
            return value;
        });
    }
    /**
     * Posts a value into the data vault's repository, without any metadata
     *
     * @param {Object} value JSON data to post into the repository
     *
     * @returns {Promise<VaultMinMeta>}
     */
    postValue(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const postValue = yield this.getPutPostValue({
                content: value,
                mimeType: MimeType.JSON,
            });
            const res = yield this.communicator.post(this.urls.postValue, true, postValue);
            return this.parsePostResult(res);
        });
    }
    /**
     * Get a specified value from the vault's repository, without any metadata
     *
     * @param {VaultItemQuery} query Query parameters to specify the record that has to be queried
     *
     * @returns {Promise<VaultValue>} the value of the specified item
     */
    getValue(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.communicator.get(this.urls.getValue(query), true);
            const item = res.data;
            try {
                // item usually contains JSON data, therefore we try to parse the string
                item.content = JSON.parse(item.content);
            }
            catch ( /* */_a) { /* */ }
            return item;
        });
    }
    /**
     * Contains all necessary transformations and checks for posting/putting data to the data vault
     *
     * @param item Data to be posted/put to the data vault
     */
    getPutPostValue(item) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { content, dri, id, mimeType, schemaDri, repo } = item;
            // POST/PUT object is slightly different to our internal structure
            const dataToPost = {
                dri,
                content: yield this.encryptOrNot(content),
                mime_type: mimeType,
            };
            if ((_a = this.supports) === null || _a === void 0 ? void 0 : _a.repos)
                dataToPost.table_name = repo !== null && repo !== void 0 ? repo : this.repo;
            if (id)
                dataToPost.id = id;
            if (schemaDri)
                dataToPost.schema_dri = schemaDri;
            try {
                if (dri)
                    dataToPost.dri = dri;
                // we only want to create hashlinks if it is explicitly specified
                // otherwise this might lead to values being overwritten due to the same calculated DRI
                else if (this.allowOnlyUniqueValues)
                    dataToPost.dri = yield generateHashlink(content);
            }
            catch ( /* if we can not generate a dri we don't care */_b) { /* if we can not generate a dri we don't care */ }
            return JSON.stringify(dataToPost);
        });
    }
    /**
     * Posts an item into the data vault's repository, including any metadata
     *
     * @param item data that is going to be passed to the data vault
     *
     * @returns {Promise<VaultMinMeta>}
     */
    postItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.communicator.post(this.urls.postItem, true, yield this.getPutPostValue(item));
            return this.parsePostResult(res);
        });
    }
    /**
     * Puts an item into the data vault's repository (update), including any metadata
     *
     * @param item data that is going to be passed to the data vault for updating the record
     */
    updateItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.communicator.put(this.urls.putItem(item), true, yield this.getPutPostValue(item));
            return res.data;
        });
    }
    /**
     * Retrieve data from the data vault's repository including its metadata
     *
     * @param {VaultItemQuery} query Query parameters to specify the record that has to be queried
     *
     * @returns {Promise<VaultItem>}
     */
    getItem(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.getItem(query), true);
            return parseVaultItem(data, this.privateKey);
        });
    }
    /**
     * Retreive provisioning data for a specific data record
     *
     * @param {VaultItemQuery} query Query parameters to specify the record that has to be queried
     *
     * @returns {Promise<string[]>}
     */
    getProvis(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.getProvis(query), true);
            return data;
        });
    }
    /**
     * Retrieve data from data vault including all metadata
     *
     * @param query Query parameters to specify the record that has to be queried
     */
    getItems(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.communicator.get(this.urls.getItems(query), true);
            // yes, vault items are wrapped in a "data" property, this is not a mistake ;-)
            const content = yield Promise.all(response.data.data.map((data) => __awaiter(this, void 0, void 0, function* () { return parseVaultItem(data, this.privateKey); })));
            return {
                content,
                paging: this.getPaging(response),
            };
        });
    }
    /**
     * Retrieve data from the data vault's repository without metadata
     *
     * @param query Query parameters to specify the records that have to be queried
     *
     * @returns array of JSON data
     */
    getValues(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.communicator.get(this.urls.getValues(query), true);
            const content = yield Promise.all(response.data.map((x) => decryptOrNot(x, this.privateKey)));
            return {
                content,
                paging: this.getPaging(response),
            };
        });
    }
    /**
     * Deletes one item
     *
     * @param query Query parameter to specify the records that have to be deleted
     *
     * @returns {Promise<VaultMinMeta>}
     */
    deleteItem(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.delete(this.urls.deleteItem(query), true);
            return data;
        });
    }
    /**
     * Returns a list of vault items, but only with metadata (no content)
     *
     * @param query Query parameter to specify the records that have to be deleted
     */
    getMetaItems(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.communicator.get(this.urls.getMetaItems(query), true);
            return {
                content: response.data.map(parseVaultItemMeta),
                paging: this.getPaging(response),
            };
        });
    }
    /**
     * Gets all repositories for the current plugin credentials
     */
    getRepos() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.getVaultSupport()).repos) {
                const { data } = yield this.communicator.get(this.urls.getRepos, true);
                return data;
            }
            /* This function is not implemented in semantic containers */
            return;
        });
    }
    /**
     * Gets all tables that are avaialable within the user's vault
     */
    getTables() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.getTables, true);
            return data.map(x => ({
                id: x,
            }));
        });
    }
    /**
     * Queries all OCA schemas that are available within the user's vault
     */
    getSchemas() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.getSchemas(), true);
            return data.map((x) => ({
                dri: x,
                title: undefined,
            }));
        });
    }
    /**
     * Gets relations to an existing data item
     *
     * @param id VaultItem's where to start looking for relations
     */
    getRelations(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.getRelations(id), true);
            return data.map((x) => {
                var _a, _b;
                return ({
                    id: x.id,
                    upstream: (_a = x.upstream) !== null && _a !== void 0 ? _a : [],
                    downstream: (_b = x.downstream) !== null && _b !== void 0 ? _b : [],
                });
            });
        });
    }
    /**
     * Checks, whether a valid endpoint is specified or not
     *
     * @returns true, if Vaultifier has all minimum necessary data and was initalized correctly.
     */
    isValid() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // currently we check the validity, if there is an endpoint specified 
                // that can deliver a response to the vault support api call
                yield this.getVaultSupport();
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    /**
     * Checks, whether the user is authenticated or not
     * Also returns true if Vault does not support authentication
     */
    isAuthenticated() {
        return __awaiter(this, void 0, void 0, function* () {
            const support = yield this.getVaultSupport();
            if (support.authentication)
                return this.communicator.hasToken();
            else
                return true;
        });
    }
    /**
     * Resolves an install code (usually 6 digits) and returns a set of VaultCredentials, if successful.
     * VaultCredentials are automatically set to the Vaultifier instance as well.
     *
     * @param {string} code Install code, usually 6 digits
     *
     * @returns {Promise<VaultCredentials>}
     */
    resolveInstallCode(code) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.get(this.urls.resolveInstallCode(code), false);
            this.credentials = {
                appKey: data.key,
                appSecret: data.secret,
            };
            return this.credentials;
        });
    }
    /**
     * Creates an eidas token that can be used as a callback parameter for the eids response POST url
     *
     * @param id Vault item's id
     */
    getEidasToken(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.communicator.post(this.urls.eidasToken, true, {
                id,
            });
            return data.token;
        });
    }
    _authorize() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const vaultCredentialsStorageKey = 'vault-credentials';
            let token;
            try {
                // const support = await this.getVaultSupport();
                const credentials = this.credentials;
                let body;
                let tokenUrl = undefined;
                if (
                // TODO: We should also check the possibility for code authentication
                // support.oAuth?.type === OAuthType.AUTHORIZATION_CODE &&
                credentials === null || 
                // TODO: We should also check the possibility for code authentication
                // support.oAuth?.type === OAuthType.AUTHORIZATION_CODE &&
                credentials === void 0 ? void 0 : 
                // TODO: We should also check the possibility for code authentication
                // support.oAuth?.type === OAuthType.AUTHORIZATION_CODE &&
                credentials.authorizationCode) {
                    // TODO: hm, this is probably not that nice...
                    // we have to rethink our authentication mechanism, it's already very complex...
                    const existingToken = this.communicator.getToken();
                    // TODO: at the moment there is no way how to refresh the token once it was issued
                    if ((yield this.isAuthenticated()) && existingToken)
                        return existingToken;
                    const pkceSecret = Storage.pop(StorageKey.PKCE_SECRET);
                    const oauthRedirectUrl = Storage.pop(StorageKey.OAUTH_REDIRECT_URL);
                    const applicationId = Storage.pop(StorageKey.APPLICATION_ID);
                    if (pkceSecret && oauthRedirectUrl) {
                        body = {
                            code: credentials.authorizationCode,
                            client_id: credentials.clientId,
                            code_verifier: pkceSecret,
                            grant_type: OAuthType.AUTHORIZATION_CODE,
                            redirect_uri: oauthRedirectUrl,
                        };
                    }
                    else if (oauthRedirectUrl && credentials.state && applicationId) {
                        tokenUrl = this.urls.getOidcSignInUrl(credentials.authorizationCode, credentials.state, oauthRedirectUrl, applicationId);
                    }
                }
                else {
                    if ((credentials === null || credentials === void 0 ? void 0 : credentials.appKey) && (credentials === null || credentials === void 0 ? void 0 : credentials.appSecret))
                        this.credentials = credentials;
                    else {
                        const storedCredentials = Storage.getObject(vaultCredentialsStorageKey);
                        if (storedCredentials) {
                            this.credentials = storedCredentials;
                        }
                        else
                            throw new Error('No valid credentials provided.');
                    }
                    body = {
                        client_id: this.credentials.appKey,
                        client_secret: this.credentials.appSecret,
                        grant_type: OAuthType.CLIENT_CREDENTIALS,
                    };
                }
                if ((_a = this.credentials) === null || _a === void 0 ? void 0 : _a.scope)
                    body.scope = this.credentials.scope;
                let response;
                if (tokenUrl)
                    response = yield this.communicator.get(tokenUrl, false);
                else
                    response = yield this.communicator.post(this.urls.token, false, body);
                token = response.data.access_token;
                // we only save the credentials if they are appKey and appSecret
                // authorizationCode does not make sense to store
                if (((_b = this.credentials) === null || _b === void 0 ? void 0 : _b.appKey) && this.credentials.appSecret) {
                    Storage.set(vaultCredentialsStorageKey, this.credentials);
                }
            }
            catch (_c) {
                throw new UnauthorizedError();
            }
            return token;
        });
    }
}
/* static functions */
/**
 * Creates a valid repo path out of the specified string parameters
 *
 * @param path
 *
 * @returns {string}
 */
Vaultifier.getRepositoryPath = (...path) => path
    // filter empty strings
    .filter(x => !!x)
    .join('.');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmF1bGl0Zmllci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92YXVsaXRmaWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQW1DLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDbkQsT0FBTyxFQUFnQixPQUFPLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzVFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUM3QyxPQUFPLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM3RSxPQUFPLEVBR0wsU0FBUyxHQW1CVixNQUFNLGNBQWMsQ0FBQztBQUN0QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFJeEMsTUFBTSxPQUFPLFVBQVU7SUFXckI7Ozs7Ozs7T0FPRztJQUNILFlBQ0UsT0FBZ0IsRUFDVCxJQUFhLEVBQ2IsV0FBOEIsRUFDOUIscUJBQTZDLEVBQzdDLHdCQUF3QixLQUFLO1FBSDdCLFNBQUksR0FBSixJQUFJLENBQVM7UUFDYixnQkFBVyxHQUFYLFdBQVcsQ0FBbUI7UUFDOUIsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUF3QjtRQUM3QywwQkFBcUIsR0FBckIscUJBQXFCLENBQVE7UUEwSnRDOzs7Ozs7OztXQVFHO1FBQ0gsc0JBQWlCLEdBQUcsQ0FBQyxPQUF3QixFQUFrQixFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQXVGL0c7Ozs7OztXQU1HO1FBQ0gsU0FBSSxHQUFHLENBQ0wsR0FBVyxFQUNYLFFBQWtCLEVBQ2xC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