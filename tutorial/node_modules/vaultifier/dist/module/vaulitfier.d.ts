import { NetworkAdapter, NetworkResponse } from './communicator';
import { MultiResponse, PrivateKeyCredentials, VaultCredentials, VaultEncryptionSupport, VaultInfo, VaultItem, VaultItemQuery, VaultItemsQuery, VaultMeta, VaultMinMeta, VaultPostItem, VaultRelation, VaultRepo, VaultSchema, VaultSupport, VaultTable, VaultValue } from './interfaces';
import { VaultifierUrls } from './urls';
export declare class Vaultifier {
    repo?: string | undefined;
    credentials?: VaultCredentials | undefined;
    privateKeyCredentials?: PrivateKeyCredentials | undefined;
    allowOnlyUniqueValues: boolean;
    private publicKey?;
    private privateKey?;
    private communicator;
    private supports?;
    private info?;
    readonly urls: VaultifierUrls;
    /**
     *
     * @param baseUrl The base url of your data vault (e.g. https://data-vault.eu).
     * @param repo Repository, where to write to. This is defined in your plugin's manifest
     * @param credentials "Identifier" (appKey) that was generated after registering the plugin. "Secret" (appSecret) that was generated after registering the plugin.
     * @param privateKeyCredentials Credentials for decrypting E2E encrypted data
     * @param allowOnlyUniqueValues Specifies, if DRI should be calculated for every value. If `true`, the data store will only allow unique values.
     */
    constructor(baseUrl?: string, repo?: string | undefined, credentials?: VaultCredentials | undefined, privateKeyCredentials?: PrivateKeyCredentials | undefined, allowOnlyUniqueValues?: boolean);
    private getPaging;
    private parsePostResult;
    /**
     * Returns an object that can be checked for supported features of the provided endpoint
     */
    getVaultSupport(): Promise<VaultSupport>;
    /**
     * Returns an object with data that describes the Vault
     */
    getVaultInfo(): Promise<VaultInfo>;
    /**
     * Retrieves the usage policy of the give data vault
     *
     * @returns the usage policy (which format is (Turtle)[https://www.w3.org/TR/turtle/]) as a string
     */
    getUsagePolicy(): Promise<string>;
    /**
     * Sets the vault's credentials
     *
     * @param credentials Object containing credentials
     */
    setCredentials(credentials: VaultCredentials): void;
    /**
     * Returns true, if vault has (probably) valid credentials
     * This does not indicate, whether the vault will accept the credentials or not!
     */
    hasCredentials(): boolean;
    /**
     * Initializes Vaultifier (authorizes against data vault if necessary)
     *
     * @returns {Promise<void>}
     */
    initialize(): Promise<void>;
    /**
     * This switches to the given repository name
     * As the data vault also provides the functionality to have public keys per repo
     * this function could be used to create a new instance of Vaultifier
     * But as this functionality is not yet active, it just changes the repo without doing anything further
     *
     * @param repoId Repository that should be used in the returned instance of Vaultifier
     */
    fromRepo(repoId: string): Promise<Vaultifier>;
    /**
     * This enables to intercept all network calls made by Vaultifier
     * This is helpful, if you are already using a library for all your network calls
     * If "setNetworkAdapter" is called without providing an adapter, Vaultifier's default adapter is used
     *
     * @param {NetworkAdapter} [adapter]
     *
     * @returns {NetworkAdapter} the network adapter that will be used by Vaultifier
     */
    setNetworkAdapter: (adapter?: NetworkAdapter | undefined) => NetworkAdapter;
    /**
     * Enables or disables end-to-end encryption
     * TODO: this should always be enabled by default
     *
     * @param isActive
     */
    setEnd2EndEncryption(isActive?: boolean): Promise<VaultEncryptionSupport>;
    getEncryptionSupport(): VaultEncryptionSupport;
    private get _usesEncryption();
    private encryptOrNot;
    /**
     * A generic method to post data to the Data Vault
     *
     * @param url Url where to send the request to. Has to start with a leading slash "/"
     * @param usesAuth Whether or not the call should be authorized or not
     * @param data Data to pass to the endpoint
     */
    post: (url: string, usesAuth?: boolean | undefined, data?: any) => Promise<NetworkResponse>;
    /**
     * A generic method to put data to the Data Vault
     *
     * @param url Url where to send the request to. Has to start with a leading slash "/"
     * @param usesAuth Whether or not the call should be authorized or not
     * @param data Data to pass to the endpoint
     */
    put: (url: string, usesAuth?: boolean | undefined, data?: any) => Promise<NetworkResponse>;
    /**
     * A generic method to get data from the Data Vault
     *
     * @param url Url where to send the request to. Has to start with a leading slash "/"
     * @param usesAuth Whether or not the call should be authorized or not
     */
    get: (url: string, usesAuth?: boolean | undefined) => Promise<NetworkResponse>;
    /**
     * Posts a value into the data vault's repository, without any metadata
     *
     * @param {Object} value JSON data to post into the repository
     *
     * @returns {Promise<VaultMinMeta>}
     */
    postValue(value: any): Promise<VaultMinMeta>;
    /**
     * Get a specified value from the vault's repository, without any metadata
     *
     * @param {VaultItemQuery} query Query parameters to specify the record that has to be queried
     *
     * @returns {Promise<VaultValue>} the value of the specified item
     */
    getValue(query: VaultItemQuery): Promise<VaultValue>;
    /**
     * Contains all necessary transformations and checks for posting/putting data to the data vault
     *
     * @param item Data to be posted/put to the data vault
     */
    private getPutPostValue;
    /**
     * Posts an item into the data vault's repository, including any metadata
     *
     * @param item data that is going to be passed to the data vault
     *
     * @returns {Promise<VaultMinMeta>}
     */
    postItem(item: VaultPostItem): Promise<VaultMinMeta>;
    /**
     * Puts an item into the data vault's repository (update), including any metadata
     *
     * @param item data that is going to be passed to the data vault for updating the record
     */
    updateItem(item: VaultPostItem): Promise<VaultMinMeta>;
    /**
     * Retrieve data from the data vault's repository including its metadata
     *
     * @param {VaultItemQuery} query Query parameters to specify the record that has to be queried
     *
     * @returns {Promise<VaultItem>}
     */
    getItem(query: VaultItemQuery): Promise<VaultItem>;
    /**
     * Retreive provisioning data for a specific data record
     *
     * @param {VaultItemQuery} query Query parameters to specify the record that has to be queried
     *
     * @returns {Promise<string[]>}
     */
    getProvis(query: VaultItemQuery): Promise<string[]>;
    /**
     * Retrieve data from data vault including all metadata
     *
     * @param query Query parameters to specify the record that has to be queried
     */
    getItems(query?: VaultItemsQuery): Promise<MultiResponse<VaultItem>>;
    /**
     * Retrieve data from the data vault's repository without metadata
     *
     * @param query Query parameters to specify the records that have to be queried
     *
     * @returns array of JSON data
     */
    getValues(query?: VaultItemsQuery): Promise<MultiResponse<any>>;
    /**
     * Deletes one item
     *
     * @param query Query parameter to specify the records that have to be deleted
     *
     * @returns {Promise<VaultMinMeta>}
     */
    deleteItem(query: VaultItemQuery): Promise<VaultMinMeta>;
    /**
     * Returns a list of vault items, but only with metadata (no content)
     *
     * @param query Query parameter to specify the records that have to be deleted
     */
    getMetaItems(query?: VaultItemsQuery): Promise<MultiResponse<VaultMeta>>;
    /**
     * Gets all repositories for the current plugin credentials
     */
    getRepos(): Promise<VaultRepo[] | undefined>;
    /**
     * Gets all tables that are avaialable within the user's vault
     */
    getTables(): Promise<VaultTable[]>;
    /**
     * Queries all OCA schemas that are available within the user's vault
     */
    getSchemas(): Promise<VaultSchema[]>;
    /**
     * Gets relations to an existing data item
     *
     * @param id VaultItem's where to start looking for relations
     */
    getRelations(id: number): Promise<VaultRelation[]>;
    /**
     * Checks, whether a valid endpoint is specified or not
     *
     * @returns true, if Vaultifier has all minimum necessary data and was initalized correctly.
     */
    isValid(): Promise<boolean>;
    /**
     * Checks, whether the user is authenticated or not
     * Also returns true if Vault does not support authentication
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Resolves an install code (usually 6 digits) and returns a set of VaultCredentials, if successful.
     * VaultCredentials are automatically set to the Vaultifier instance as well.
     *
     * @param {string} code Install code, usually 6 digits
     *
     * @returns {Promise<VaultCredentials>}
     */
    resolveInstallCode(code: string): Promise<VaultCredentials>;
    /**
     * Creates an eidas token that can be used as a callback parameter for the eids response POST url
     *
     * @param id Vault item's id
     */
    getEidasToken(id: number): Promise<string>;
    private _authorize;
    /**
     * Creates a valid repo path out of the specified string parameters
     *
     * @param path
     *
     * @returns {string}
     */
    static getRepositoryPath: (...path: Array<string>) => string;
}
