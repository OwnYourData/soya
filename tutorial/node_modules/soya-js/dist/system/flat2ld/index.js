var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flat2ld = void 0;
const rdf_1 = require("../../utils/rdf");
const sparql_1 = require("../../utils/sparql");
const iterateItemProps = (builder, item, flatJson, base) => __awaiter(this, void 0, void 0, function* () {
    for (const prop in flatJson) {
        const val = flatJson[prop];
        if (typeof val === 'object' &&
            // typeof val also outputs 'object' for Arrays
            // therefore we have to check them separately here
            // arrays should be acquired directly, therefore we don't include them in this "if"
            !Array.isArray(val)) {
            const refClasses = yield builder.query(`
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      PREFIX base: <${base}>
      SELECT ?o WHERE {
        base:${prop} rdfs:range ?o .
      }`);
            if (refClasses[0]) {
                const refClass = refClasses[0].get('?o');
                if (refClass) {
                    const subItem = {
                        "@type": refClass.replace(base, ''),
                    };
                    item[prop] = [subItem];
                    yield iterateItemProps(builder, subItem, val, base);
                }
            }
        }
        else
            item[prop] = flatJson[prop];
    }
});
const flat2ld = (flatJson, soyaStructure) => __awaiter(this, void 0, void 0, function* () {
    const graph = [];
    const base = soyaStructure["@context"]["@base"];
    const retItem = {
        "@context": {
            "@version": 1.1,
            "@vocab": base,
        },
        "@graph": graph,
    };
    const flatItems = Array.isArray(flatJson) ? flatJson : [flatJson];
    const dataSet = yield (0, rdf_1.parseJsonLd)(soyaStructure);
    const builder = new sparql_1.SparqlQueryBuilder(dataSet);
    for (const flatItem of flatItems) {
        const mainClasses = yield builder.query(`
    PREFIX owl: <http://www.w3.org/2002/07/owl#>
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    PREFIX soya: <https://w3id.org/soya/ns#>
    SELECT ?s WHERE {
      ?s rdfs:subClassOf soya:Base .
    }`);
        const mainClass = mainClasses[0];
        if (mainClass) {
            const mainClassName = mainClass.get('?s');
            if (mainClassName) {
                const item = {
                    "@type": mainClassName.replace(retItem["@context"]["@vocab"], ''),
                };
                graph.push(item);
                yield iterateItemProps(builder, item, flatItem, base);
            }
        }
    }
    return retItem;
});
exports.flat2ld = flat2ld;
//# sourceMappingURL=index.js.map