import { ContextParser, IExpandOptions, IJsonLdContextNormalizedRaw, JsonLdContext, JsonLdContextNormalized } from "jsonld-context-parser";
import * as RDF from "@rdfjs/types";
import { ContextTree } from "./ContextTree";
import { IJsonLdParserOptions, JsonLdParser } from "./JsonLdParser";
/**
 * Data holder for parsing information.
 */
export declare class ParsingContext {
    static EXPAND_OPTIONS: {
        [version: number]: IExpandOptions;
    };
    readonly contextParser: ContextParser;
    readonly streamingProfile: boolean;
    readonly baseIRI?: string;
    readonly produceGeneralizedRdf: boolean;
    readonly allowSubjectList: boolean;
    readonly processingMode: string;
    readonly strictValues: boolean;
    readonly validateValueIndexes: boolean;
    readonly rootContext: Promise<JsonLdContextNormalized>;
    readonly defaultGraph?: RDF.NamedNode | RDF.BlankNode | RDF.DefaultGraph;
    readonly rdfDirection?: 'i18n-datatype' | 'compound-literal';
    readonly normalizeLanguageTags?: boolean;
    readonly streamingProfileAllowOutOfOrderPlainType?: boolean;
    readonly processingStack: boolean[];
    readonly processingType: boolean[];
    readonly emittedStack: boolean[];
    readonly idStack: RDF.Term[][];
    readonly graphStack: boolean[];
    readonly graphContainerTermStack: ({
        [index: string]: RDF.NamedNode | RDF.BlankNode;
    })[];
    readonly listPointerStack: ({
        value?: RDF.Term;
        listRootDepth: number;
        listId: RDF.Term;
    })[];
    readonly contextTree: ContextTree;
    readonly literalStack: boolean[];
    readonly validationStack: {
        valid: boolean;
        property: boolean;
    }[];
    readonly unaliasedKeywordCacheStack: any[];
    readonly jsonLiteralStack: boolean[];
    readonly unidentifiedValuesBuffer: {
        predicate: RDF.Term;
        object: RDF.Term;
        reverse: boolean;
    }[][];
    readonly unidentifiedGraphsBuffer: {
        subject: RDF.Term;
        predicate: RDF.Term;
        object: RDF.Term;
    }[][];
    pendingContainerFlushBuffers: {
        depth: number;
        keys: any[];
    }[];
    topLevelProperties: boolean;
    activeProcessingMode: number;
    private readonly parser;
    constructor(options: IParsingContextOptions);
    /**
     * Parse the given context with the configured options.
     * @param {JsonLdContext} context A context to parse.
     * @param {JsonLdContextNormalized} parentContext An optional parent context.
     * @param {boolean} ignoreProtection If @protected term checks should be ignored.
     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.
     */
    parseContext(context: JsonLdContext, parentContext?: IJsonLdContextNormalizedRaw, ignoreProtection?: boolean): Promise<JsonLdContextNormalized>;
    /**
     * Check if the given context is valid.
     * If not, an error will be thrown.
     * @param {JsonLdContextNormalized} context A context.
     */
    validateContext(context: JsonLdContextNormalized): void;
    /**
     * Get the context at the given path.
     * @param {keys} keys The path of keys to get the context at.
     * @param {number} offset The path offset, defaults to 1.
     * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.
     */
    getContext(keys: any[], offset?: number): Promise<JsonLdContextNormalized>;
    /**
     * Get the context at the given path.
     * Non-propagating contexts will be skipped,
     * unless the context at that exact depth is retrieved.
     *
     * This ONLY takes into account context propagation logic,
     * so this should usually not be called directly,
     * call {@link #getContext} instead.
     *
     * @param keys The path of keys to get the context at.
     * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.
     */
    getContextPropagationAware(keys: string[]): Promise<{
        context: JsonLdContextNormalized;
        depth: number;
    }>;
    /**
     * Start a new job for parsing the given value.
     * @param {any[]} keys The stack of keys.
     * @param value The value to parse.
     * @param {number} depth The depth to parse at.
     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.
     * @return {Promise<void>} A promise resolving when the job is done.
     */
    newOnValueJob(keys: any[], value: any, depth: number, lastDepthCheck: boolean): Promise<void>;
    /**
     * Flush the pending container flush buffers
     * @return {boolean} If any pending buffers were flushed.
     */
    handlePendingContainerFlushBuffers(): Promise<boolean>;
    /**
     * Emit the given quad into the output stream.
     * @param {number} depth The depth the quad was generated at.
     * @param {Quad} quad A quad to emit.
     */
    emitQuad(depth: number, quad: RDF.BaseQuad): void;
    /**
     * Emit the given error into the output stream.
     * @param {Error} error An error to emit.
     */
    emitError(error: Error): void;
    /**
     * Emit the given context into the output stream under the 'context' event.
     * @param {JsonLdContext} context A context to emit.
     */
    emitContext(context: JsonLdContext): void;
    /**
     * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.
     * @param {number} depth A depth.
     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of
     *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.
     */
    getUnidentifiedValueBufferSafe(depth: number): {
        predicate: RDF.Term;
        object: RDF.Term;
        reverse: boolean;
    }[];
    /**
     * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.
     * @param {number} depth A depth.
     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of
     *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.
     */
    getUnidentifiedGraphBufferSafe(depth: number): {
        subject: RDF.Term;
        predicate: RDF.Term;
        object: RDF.Term;
    }[];
    /**
     * @return IExpandOptions The expand options for the active processing mode.
     */
    getExpandOptions(): IExpandOptions;
    /**
     * Shift the stack at the given offset to the given depth.
     *
     * This will override anything in the stack at `depth`,
     * and this will remove anything at `depth + depthOffset`
     *
     * @param depth The target depth.
     * @param depthOffset The origin depth, relative to `depth`.
     */
    shiftStack(depth: number, depthOffset: number): void;
}
/**
 * Constructor arguments for {@link ParsingContext}
 */
export interface IParsingContextOptions extends IJsonLdParserOptions {
    /**
     * The parser instance.
     */
    parser: JsonLdParser;
}
