"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerHandlerIndex = void 0;
const jsonld_context_parser_1 = require("jsonld-context-parser");
const EntryHandlerPredicate_1 = require("../entryhandler/EntryHandlerPredicate");
const Util_1 = require("../Util");
/**
 * Container handler for @index.
 *
 * This will ignore the current key and add this entry to the parent node.
 */
class ContainerHandlerIndex {
    canCombineWithGraph() {
        return true;
    }
    async handle(containers, parsingContext, util, keys, value, depth) {
        if (!Array.isArray(value)) {
            const graphContainer = '@graph' in containers;
            // Check if the container is a property-based container by checking if there is a valid @index.
            const context = await parsingContext.getContext(keys);
            const indexKey = keys[depth - 1];
            const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);
            if (indexPropertyRaw) {
                // Validate the @index value
                if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {
                    throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);
                }
                if (typeof indexPropertyRaw !== 'string') {
                    throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);
                }
                // When @index is used, values must be node values, unless @type: @id is defined in the context
                if (typeof value !== 'object') {
                    // Error if we don't have @type: @id
                    if (Util_1.Util.getContextValueType(context, indexKey) !== '@id') {
                        throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);
                    }
                    // Add an @id to the stack, so our expanded @index value can make use of it
                    const id = util.resourceToTerm(context, value);
                    if (id) {
                        parsingContext.idStack[depth + 1] = [id];
                    }
                }
                // Expand the @index value
                const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);
                if (indexProperty) {
                    const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);
                    if (graphContainer) {
                        // When we're in a graph container, attach the index to the graph identifier
                        const graphId = await util.getGraphContainerValue(keys, depth + 1);
                        for (const indexValue of indexValues) {
                            parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));
                        }
                    }
                    else {
                        // Otherwise, attach the index to the node identifier
                        for (const indexValue of indexValues) {
                            await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false);
                        }
                    }
                }
            }
            const depthOffset = graphContainer ? 2 : 1;
            await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);
            // Flush any pending flush buffers
            await parsingContext.handlePendingContainerFlushBuffers();
        }
        parsingContext.emittedStack[depth] = false; // We have emitted a level higher
    }
}
exports.ContainerHandlerIndex = ContainerHandlerIndex;
//# sourceMappingURL=ContainerHandlerIndex.js.map