var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSoyaForm = void 0;
const errors_1 = require("../../errors");
const rdf_1 = require("../../utils/rdf");
const sparql_1 = require("../../utils/sparql");
__exportStar(require("./interfaces"), exports);
const splitLast = (value, split) => {
    if (!value)
        return value;
    const arr = value.split(split);
    return arr[arr.length - 1];
};
const getLastUriPart = (uri) => {
    return splitLast(splitLast(uri, '/'), '#');
};
class FormBuilder {
    constructor(_builder, _mainClassUri, options) {
        this._builder = _builder;
        this._mainClassUri = _mainClassUri;
        this.options = options;
        this._getTranslatedProperty = (propUri, predicate = 'rdfs:label') => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (!(0, rdf_1.isIRI)(propUri))
                return;
            const language = (_a = this.options.language) !== null && _a !== void 0 ? _a : 'en';
            const query = yield this._builder.query(`
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      SELECT * WHERE {
        <${propUri}> ${predicate} ?var .
        FILTER(lang(?var) = "${language}")
      }`);
            if (query[0])
                return ((_c = (_b = query[0].get('?var')) === null || _b === void 0 ? void 0 : _b.split('@')[0]) === null || _c === void 0 ? void 0 : _c.slice(1, -1)) || undefined;
            else
                return;
        });
        this._handleClass = (name, classUri, layoutSubPath = '') => __awaiter(this, void 0, void 0, function* () {
            const schema = {
                type: 'object',
                properties: {},
                required: [],
            };
            // this if is just here to please typescript
            // obviously it does not get that schema.properties is always set
            // weirdly it thinks it could undefined...
            if (!schema.properties || !schema.required)
                return schema;
            const layout = {
                type: 'Group',
                // @ts-expect-error FIXME: label is not recognized, probably an error in official types
                // capitalize first letter
                label: name.charAt(0).toUpperCase() + name.slice(1),
                elements: [],
            };
            this._ui.elements.push(layout);
            const query = `
    PREFIX owl: <http://www.w3.org/2002/07/owl#>
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    SELECT * WHERE {
      ?prop rdfs:domain <${classUri}> .
      ?prop a owl:DatatypeProperty .
      ?prop rdfs:range ?range .
    }`;
            const allProps = yield this._builder.query(query);
            for (const prop of allProps) {
                const propUri = prop.get('?prop');
                const range = prop.get('?range');
                if (!range || !propUri)
                    continue;
                const propName = getLastUriPart(propUri);
                if (!propName)
                    continue;
                const propSchema = schema.properties[propName] = {};
                // we don't check URIs from w3.org for linked classes
                // as they can be used as "primitive" data types
                // e.g. owl:Class with an enumeration of possible classes
                if (!range.startsWith('http://www.w3.org')) {
                    // check if URI exists as a graph object
                    const refRange = yield this._builder.query(`
        SELECT * WHERE {
          <${range}> ?p ?o .
        }`);
                    if (refRange.length !== 0) {
                        // it's a graph object
                        // start recursion
                        schema.properties[propName] = yield this._handleClass(propName, range, `${layoutSubPath}${propName}/properties/`);
                        // proceed with next property
                        continue;
                    }
                }
                // it's something else (e.g. XML schema)
                // try to get hash from XML schema string
                propSchema.type = 'string';
                switch (range.split('#')[1]) {
                    case 'date':
                        propSchema.format = 'date';
                        break;
                    case 'time':
                        propSchema.format = 'time';
                        break;
                    case 'dateTime':
                        propSchema.format = 'date-time';
                        break;
                }
                // see if we can get some information out of a SHACL shape
                const shaclConstraintList = yield this._builder.query(`
          PREFIX sh: <http://www.w3.org/ns/shacl#>
          SELECT * WHERE {
            ?shprop sh:path <${propUri}> .
            OPTIONAL { ?shprop sh:minCount ?minCount . }
            OPTIONAL { ?shprop sh:maxLength ?maxLength . }
            OPTIONAL { ?shprop sh:pattern ?pattern . }
            OPTIONAL { ?shprop sh:in ?in . }
          }`);
                let minCount = 0;
                if (shaclConstraintList[0]) {
                    const shaclConstraint = shaclConstraintList[0];
                    const _minCount = shaclConstraint.get('?minCount');
                    if (_minCount && (minCount = parseInt(_minCount)) >= 1)
                        schema.required.push(propName);
                    const maxLength = shaclConstraint.get('?maxLength');
                    if (maxLength)
                        propSchema.maxLength = parseInt(maxLength);
                    const pattern = shaclConstraint.get('?pattern');
                    if (pattern)
                        propSchema.pattern = pattern;
                }
                // TODO: unfortunately this query is SUPER SLOW for big graphs
                // ... I mean, really really slow
                // ... unlike this one https://www.youtube.com/watch?v=XeD_WB17NBc
                // most probably this is due to the * operator
                // const multiItems = await this._builder.query(`
                //   PREFIX sh: <http://www.w3.org/ns/shacl#>
                //   PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
                //   SELECT * WHERE {
                //       ?shprop sh:path ?propUri .
                //       ?shprop sh:in ?in .
                //       ?in rdf:rest*/rdf:first ?entry .
                //   }`);
                // BEGIN of ugly rewrite of above SPARQL query
                const firstItem = yield this._builder.query(`
          PREFIX sh: <http://www.w3.org/ns/shacl#>
          PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
          SELECT * WHERE {
            ?shprop sh:path <${propUri}> .
            ?shprop sh:in ?in .
            ?in rdf:first ?entry .
          }`);
                // this enum format is defined by jsonforms
                // however they don't seem to export an interface
                const enumList = [];
                const addEnumItem = (valueOrIRI) => __awaiter(this, void 0, void 0, function* () {
                    var _d, _e;
                    const _value = (_d = getLastUriPart(valueOrIRI)) !== null && _d !== void 0 ? _d : valueOrIRI;
                    enumList.push({
                        const: _value,
                        title: (_e = yield this._getTranslatedProperty(valueOrIRI)) !== null && _e !== void 0 ? _e : _value,
                    });
                });
                if (firstItem.length !== 0) {
                    let item = firstItem[0];
                    const firstValue = item === null || item === void 0 ? void 0 : item.get('?entry');
                    if (item && firstValue) {
                        yield addEnumItem(firstValue);
                        const subItems = yield this._builder.query(`
              PREFIX sh: <http://www.w3.org/ns/shacl#>
              PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
              SELECT * WHERE {   
                ?in rdf:rest ?rest .
                ?rest rdf:first ?first .
              }`);
                        let rest = item.get('?in');
                        // this resolves the chained list of rest and first
                        while (rest) {
                            const tempItem = subItems.find(x => x.get('?in') === rest);
                            const tempRest = tempItem === null || tempItem === void 0 ? void 0 : tempItem.get('?rest');
                            const value = tempItem === null || tempItem === void 0 ? void 0 : tempItem.get('?first');
                            if (value)
                                yield addEnumItem(value);
                            rest = tempRest;
                        }
                    }
                }
                // END of ugly rewrite of above SPARQL query
                if (enumList.length !== 0) {
                    if (minCount >= 1) {
                        propSchema.type = 'array';
                        propSchema.uniqueItems = true;
                    }
                    propSchema.oneOf = enumList;
                }
                const element = {
                    type: 'Control',
                    // @ts-expect-error FIXME: scope is not recognized, probably an error in official types
                    scope: `#/properties/${layoutSubPath}${propName}`,
                };
                layout.elements.push(element);
                // @ts-expect-error FIXME: label is not recognized, probably an error in official types
                element.label = yield this._getTranslatedProperty(propUri);
                // @ts-expect-error FIXME: label is not recognized, probably an error in official types
                element.description = yield this._getTranslatedProperty(propUri, 'rdfs:comment');
            }
            return schema;
        });
        this.build = () => __awaiter(this, void 0, void 0, function* () {
            const name = getLastUriPart(this._mainClassUri);
            if (!name)
                throw new errors_1.FormRenderError('Main class name not found.');
            const retVal = {
                schema: yield this._handleClass(name, this._mainClassUri),
                ui: this._ui,
                options: [],
            };
            // FIXME: This query does unfortunately not work
            // although it does work within graphDB
            // Therefore we have to go the manual, programmatic way ...
            // get all available languages
            // const langQuery = await this._builder.query(`
            // PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
            // SELECT DISTINCT (lang(?label) as ?lang) WHERE {
            //     ?shprop rdfs:label ?label .
            // }`);
            const langQuery = yield this._builder.query(`
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    SELECT ?label WHERE {
        ?shprop rdfs:label ?label .
    }`);
            if (langQuery.length !== 0)
                retVal.options = langQuery
                    .map(x => x.get('?label'))
                    .map(x => {
                    const s = x === null || x === void 0 ? void 0 : x.split('@');
                    if (s)
                        return s[s.length - 1];
                    return;
                })
                    .filter((val, index, self) => !!val && self.indexOf(val) === index)
                    .map(lang => ({
                    language: lang,
                }));
            return retVal;
        });
        this._ui = {
            type: 'VerticalLayout',
            elements: [],
        };
    }
}
const getSoyaForm = (soyaStructure, options = {}) => __awaiter(this, void 0, void 0, function* () {
    // check if there is a static form available
    // ui and schema are currently our "fingerprint" for finding form schemas
    var _a, _b, _c;
    const staticForms = soyaStructure["@graph"].filter(x => !!x.ui || !!x.schema);
    const dataSet = yield (0, rdf_1.parseJsonLd)(soyaStructure);
    const builder = new sparql_1.SparqlQueryBuilder(dataSet);
    const classes = yield builder.query(`
  PREFIX owl: <http://www.w3.org/2002/07/owl#>
  PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
  SELECT ?s WHERE {
    ?s a owl:Class .
    # exclude all classes that are nested in a parent class
    FILTER NOT EXISTS {
      ?rel rdfs:range ?s .
    }
  }`);
    let defaultForm = undefined;
    if (classes[0]) {
        // we only support one base for now
        const mainClass = classes[0];
        const mainClassUri = mainClass.get('?s');
        if (mainClassUri) {
            defaultForm = yield new FormBuilder(builder, mainClassUri, options).build();
        }
    }
    // check if we can find the requested form in our static forms
    const requestedForm = (_a = staticForms.find(f => f.language == options.language &&
        f.tag == options.tag
    // fallback is of course our computed form
    )) !== null && _a !== void 0 ? _a : defaultForm;
    let formOptions = [];
    // add default options, if available
    if (defaultForm)
        formOptions = formOptions.concat(defaultForm.options);
    // add static options
    formOptions = formOptions.concat(staticForms.map(f => ({
        language: f.language,
        tag: f.tag,
    })));
    // substitute schema with schema from computed form, if not available
    const schema = (_b = requestedForm === null || requestedForm === void 0 ? void 0 : requestedForm.schema) !== null && _b !== void 0 ? _b : defaultForm === null || defaultForm === void 0 ? void 0 : defaultForm.schema;
    // substitute ui with ui from computed form, if not available
    const ui = (_c = requestedForm === null || requestedForm === void 0 ? void 0 : requestedForm.ui) !== null && _c !== void 0 ? _c : defaultForm === null || defaultForm === void 0 ? void 0 : defaultForm.ui;
    if (schema && ui)
        return {
            schema,
            ui,
            // distinct the list of options
            // so that we do not show an option combination twice
            options: formOptions.filter((fo, idx, arr) => {
                return arr.findIndex((val) => val.language === fo.language &&
                    val.tag === fo.tag) === idx;
            })
        };
    else
        throw new errors_1.FormRenderError('Could not find static forms and could not render default form');
});
exports.getSoyaForm = getSoyaForm;
//# sourceMappingURL=index.js.map