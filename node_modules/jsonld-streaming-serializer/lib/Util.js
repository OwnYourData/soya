"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = void 0;
const jsonld_context_parser_1 = require("jsonld-context-parser");
/**
 * Utility functions and methods.
 */
class Util {
    /**
     * Convert an RDF term to a JSON value.
     * @param {Term} term An RDF term.
     * @param {JsonLdContextNormalized} context The context.
     * @param {ITermToValueOptions} options Conversion options.
     * @return {any} A JSON value.
     */
    static termToValue(term, context, options = {
        compactIds: false,
        useNativeTypes: false,
    }) {
        switch (term.termType) {
            case 'NamedNode':
                const compacted = context.compactIri(term.value, options.vocab);
                return options.compactIds ? compacted : { '@id': compacted };
            case 'DefaultGraph':
                return options.compactIds ? term.value : { '@id': term.value };
            case 'BlankNode':
                const id = `_:${term.value}`;
                return options.compactIds ? id : { '@id': id };
            case 'Literal':
                // Handle JSON datatype
                if (term.datatype.value === Util.RDF_JSON) {
                    let parsedJson;
                    try {
                        parsedJson = JSON.parse(term.value);
                    }
                    catch (e) {
                        throw new jsonld_context_parser_1.ErrorCoded('Invalid JSON literal: ' + e.message, jsonld_context_parser_1.ERROR_CODES.INVALID_JSON_LITERAL);
                    }
                    return {
                        '@value': parsedJson,
                        '@type': '@json',
                    };
                }
                // Handle rdfDirection: i18n-datatype
                if (options.rdfDirection === 'i18n-datatype' && term.datatype.value.startsWith(Util.I18N)) {
                    const [language, direction] = term.datatype.value
                        .substr(Util.I18N.length, term.datatype.value.length)
                        .split('_');
                    return Object.assign(Object.assign({ '@value': term.value }, language ? { '@language': language } : {}), direction ? { '@direction': direction } : {});
                }
                const stringType = term.datatype.value === Util.XSD_STRING;
                const rawValue = {
                    '@value': !stringType && options.useNativeTypes
                        ? Util.stringToNativeType(term.value, term.datatype.value) : term.value,
                };
                if (term.language) {
                    return Object.assign(Object.assign({}, rawValue), { '@language': term.language });
                }
                else if (!stringType && typeof rawValue['@value'] === 'string') {
                    return Object.assign(Object.assign({}, rawValue), { '@type': term.datatype.value });
                }
                else {
                    return rawValue;
                }
        }
    }
    /**
     * Convert a string term to a native type.
     * If no conversion is possible, the original string will be returned.
     * @param {string} value An RDF term's string value.
     * @param {string} type
     * @return {any}
     */
    static stringToNativeType(value, type) {
        if (type.startsWith(Util.XSD)) {
            const xsdType = type.substr(Util.XSD.length);
            switch (xsdType) {
                case 'boolean':
                    if (value === 'true') {
                        return true;
                    }
                    else if (value === 'false') {
                        return false;
                    }
                    throw new Error(`Invalid xsd:boolean value '${value}'`);
                case 'integer':
                case 'number':
                case 'int':
                case 'byte':
                case 'long':
                    const parsedInt = parseInt(value, 10);
                    if (isNaN(parsedInt)) {
                        throw new Error(`Invalid xsd:integer value '${value}'`);
                    }
                    return parsedInt;
                case 'float':
                case 'double':
                    const parsedFloat = parseFloat(value);
                    if (isNaN(parsedFloat)) {
                        throw new Error(`Invalid xsd:float value '${value}'`);
                    }
                    return parsedFloat;
            }
        }
        return value;
    }
}
exports.Util = Util;
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.XSD_STRING = Util.XSD + 'string';
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.RDF_TYPE = Util.RDF + 'type';
Util.RDF_JSON = Util.RDF + 'JSON';
Util.I18N = 'https://www.w3.org/ns/i18n#';
//# sourceMappingURL=Util.js.map