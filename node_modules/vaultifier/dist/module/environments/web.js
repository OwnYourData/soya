var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { UserManager } from "oidc-client";
import { Vaultifier } from "..";
import { StorageKey } from "../constants";
import { getRandomString } from '../crypto';
import { OAuthType } from "../interfaces";
import { Storage } from "../storage";
import { VaultifierUrls } from "../urls";
const defaultOptions = {
    repo: undefined,
    clientId: undefined,
    baseUrlParamName: 'PIA_URL',
    appKeyParamName: 'APP_KEY',
    appSecretParamName: 'APP_SECRET',
    masterKeyParamName: 'MASTER_KEY',
    nonceParamName: 'NONCE',
    clientIdParamName: 'client_id',
    clientSecretParamName: 'client_secret',
    authorizationCodeParamName: 'code',
    stateParamName: 'state',
};
export class VaultifierWeb {
    constructor(options, vaultifier) {
        this.options = options;
        this.vaultifier = vaultifier;
        this.initialize = (config = {}) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const vaultifier = this.vaultifier;
            if (!vaultifier)
                return undefined;
            // vaultifier must be valid in order to proceed with initialization
            if (!vaultifier.isValid())
                return undefined;
            const { oAuthType, } = config;
            const { appKeyParamName, appSecretParamName, authorizationCodeParamName, stateParamName, clientIdParamName, clientSecretParamName, masterKeyParamName, nonceParamName, } = this.options;
            let { clientId, } = this.options;
            const getParam = VaultifierWeb._getParamAccessor();
            const appKey = getParam(appKeyParamName);
            const appSecret = getParam(appSecretParamName);
            // if clientId parameter is specified as query parameter it is already the second step client id parameter of OAuth
            clientId = (_a = getParam(clientIdParamName)) !== null && _a !== void 0 ? _a : clientId;
            const authorizationCode = getParam(authorizationCodeParamName);
            let credentials = undefined;
            if (appKey && appSecret)
                credentials = {
                    appKey,
                    appSecret,
                };
            else if (authorizationCode && clientId)
                credentials = {
                    authorizationCode,
                    clientId,
                    state: getParam(stateParamName),
                };
            const masterKey = getParam(masterKeyParamName);
            const nonce = getParam(nonceParamName);
            const end2end = (masterKey && nonce) ? {
                masterKey,
                nonce,
            } : undefined;
            vaultifier.credentials = credentials;
            vaultifier.privateKeyCredentials = end2end;
            try {
                // try initializing vaultifier to see if credentials are working
                yield vaultifier.initialize();
            }
            catch ( /* */_b) { /* */ }
            // if we could not authorize until this stage
            // we try to login via OAuth, if supported
            const isAuthenticated = yield vaultifier.isAuthenticated();
            if (!isAuthenticated) {
                const oAuthSupport = oAuthType;
                if (clientId && oAuthSupport && oAuthSupport.type === OAuthType.AUTHORIZATION_CODE) {
                    // create PKCE secret
                    const pkceSecret = getRandomString(32);
                    // const hashedSecret = btoa(await createSha256Hex(pkceSecret));
                    const redirectUrl = VaultifierUrls.getRedirectUrl();
                    // we need this secret for later OAuth token retrieval
                    Storage.set(StorageKey.PKCE_SECRET, pkceSecret);
                    Storage.set(StorageKey.OAUTH_REDIRECT_URL, redirectUrl);
                    window.location.href = vaultifier.urls.getOAuthAuthorizationCode(clientId, window.encodeURIComponent(redirectUrl), pkceSecret);
                    // we just wait forever as the browser is now changing the visible page ;-)
                    yield new Promise(() => undefined);
                }
                const idprov = oAuthType;
                if (idprov === null || idprov === void 0 ? void 0 : idprov.authority) {
                    const redirectUrl = VaultifierUrls.getRedirectUrl();
                    Storage.set(StorageKey.APPLICATION_ID, idprov.applicationId);
                    Storage.set(StorageKey.OAUTH_REDIRECT_URL, redirectUrl);
                    const um = new UserManager({
                        authority: idprov.authority,
                        client_id: idprov.clientId,
                        scope: idprov.scope,
                        response_type: idprov.responseType,
                        redirect_uri: redirectUrl,
                    });
                    um.signinRedirect();
                    // we just wait forever as the browser is now changing the visible page ;-)
                    yield new Promise(() => undefined);
                }
            }
            const newUrl = new URL(window.location.href);
            // remove sensitive information while preserving probably important url parameters
            newUrl.searchParams.delete(appKeyParamName);
            newUrl.searchParams.delete(appSecretParamName);
            newUrl.searchParams.delete(masterKeyParamName);
            newUrl.searchParams.delete(nonceParamName);
            newUrl.searchParams.delete(clientIdParamName);
            newUrl.searchParams.delete(clientSecretParamName);
            newUrl.searchParams.delete(authorizationCodeParamName);
            newUrl.searchParams.delete(stateParamName);
            window.history.replaceState(undefined, document.title, newUrl.toString());
            return vaultifier;
        });
    }
    /**
     * Creates a Vaultifier object by retrieving connection data from URL query parameters
     */
    static create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const getParam = VaultifierWeb._getParamAccessor();
            let _options = defaultOptions;
            if (_options)
                _options = Object.assign(Object.assign({}, _options), options);
            const { baseUrlParamName, repo, } = _options;
            let { baseUrl } = _options;
            if (!baseUrl) {
                baseUrl = getParam(baseUrlParamName);
                if (baseUrl) {
                    // in web environments we want to persist the base url
                    // if it was passed via URL parameter
                    // this is because if we use OAuth for login
                    // we'll lose all parameters after redirect, hence we have to persist it
                    Storage.set(StorageKey.BASE_URL, baseUrl);
                }
                else
                    // first of all we try to fetch a stored value (see above for saving the value)
                    // if this does not work we just fall back to the window's location origin, if there is no parameter specified
                    baseUrl = Storage.get(StorageKey.BASE_URL) || window.location.origin;
            }
            let vaultifier = new Vaultifier(baseUrl, repo);
            try {
                yield vaultifier.getVaultSupport();
            }
            catch (_a) {
                // if baseUrl was specified, we try it with Vaultifier's default value
                // therefore passing undefined
                if (baseUrl) {
                    vaultifier = new Vaultifier(undefined, repo);
                    try {
                        yield vaultifier.getVaultSupport();
                    }
                    catch (e) {
                        console.error(e);
                        vaultifier = undefined;
                    }
                }
            }
            return new VaultifierWeb(_options, vaultifier);
        });
    }
}
VaultifierWeb._getParamAccessor = () => {
    const params = new URL(window.location.href).searchParams;
    return (name) => params.get(name) || undefined;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vudmlyb25tZW50cy93ZWIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUUxQyxPQUFPLEVBQXVDLFVBQVUsRUFBRSxNQUFNLElBQUksQ0FBQztBQUNyRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDNUMsT0FBTyxFQUFFLFNBQVMsRUFBMkMsTUFBTSxlQUFlLENBQUM7QUFDbkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBeUR6QyxNQUFNLGNBQWMsR0FBeUI7SUFDM0MsSUFBSSxFQUFFLFNBQVM7SUFDZixRQUFRLEVBQUUsU0FBUztJQUNuQixnQkFBZ0IsRUFBRSxTQUFTO0lBQzNCLGVBQWUsRUFBRSxTQUFTO0lBQzFCLGtCQUFrQixFQUFFLFlBQVk7SUFDaEMsa0JBQWtCLEVBQUUsWUFBWTtJQUNoQyxjQUFjLEVBQUUsT0FBTztJQUN2QixpQkFBaUIsRUFBRSxXQUFXO0lBQzlCLHFCQUFxQixFQUFFLGVBQWU7SUFDdEMsMEJBQTBCLEVBQUUsTUFBTTtJQUNsQyxjQUFjLEVBQUUsT0FBTztDQUN4QixDQUFDO0FBRUYsTUFBTSxPQUFPLGFBQWE7SUFPeEIsWUFDa0IsT0FBNkIsRUFDN0IsVUFBdUI7UUFEdkIsWUFBTyxHQUFQLE9BQU8sQ0FBc0I7UUFDN0IsZUFBVSxHQUFWLFVBQVUsQ0FBYTtRQTJFekMsZUFBVSxHQUFHLENBQU8sU0FBcUIsRUFBRSxFQUFtQyxFQUFFOztZQUM5RSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBRW5DLElBQUksQ0FBQyxVQUFVO2dC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